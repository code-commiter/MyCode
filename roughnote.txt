I believe we've discussed this before, there’s always a trade-off between performance, simplicity, and readability. Knowing when to prioritize each aspect is where expertise comes into play. While the loop count is high, the null check means that no code executes during those iterations. If we were making a database or API call, your concerns would be more relevant; however, in this case, we likely won’t save even a millisecond.

If we loop through the user parameters, we’d need to introduce additional conditional logic, which would complicate the code. We covered this a week ago, and if you still think your approach is better, I encourage you to conduct some performance testing to see how much time you can actually save.

One more point to consider is that this logic will run only once per pipeline. Once the parameters are converted to the new pipeline, this logic will no longer be used. Therefore, the 18,000 builds won't rely on this temporary solution, which is intended to last only a few months.

It’s also important to note that looping through target parameters can be applied across all 23 pipelines. I trust you’ve considered all options.

For now, we’ll proceed with our current approach. However, if your method demonstrates significant benefits, we can certainly reevaluate. Remember, saving 1 millisecond per build across 18,000 builds only amounts to 18 seconds per daay, which is minimal.



def startTime = System.nanoTime()
def count = 0

(1..Integer.MAX_VALUE).each { 
    count++ // Empty operation
    if (System.nanoTime() - startTime >= 1_000_000) { // Stop after 1ms
        return
    }
}

println "Executed $count iterations in 1 ms"
