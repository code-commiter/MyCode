def removeComments(fileContent) {
    // Remove single line comments and block comments
    return fileContent.replaceAll(/\/\/.*?$|\/\*.*?\*\//, '', [Pattern.MULTILINE])
}

def validateAssignments(pipelineContent) {
    // Pattern for invalid cases (variable-to-variable assignments and method definitions)
    def invalidPattern = /(\w+)\s*=\s*(\w+)|def\s+\w+\s*\(\s*\)\s*\{/

    // Return false if any invalid patterns are found
    return !(pipelineContent =~ invalidPattern) // Return false if invalid
}

def validatePipelines(fileContent) {
    // Remove comments before validation
    fileContent = removeComments(fileContent)

    // Regex to match the pipeline name and its content
    def pipelinePattern = /(?<name>\w+)\s*\n?\s*\{([^}]*\{[^}]*\}[^}]*)*\}/

    // Find all pipelines in the content
    def pipelines = fileContent.findAll(pipelinePattern)

    // Return false if more than one pipeline is found
    if (pipelines.size() > 1) {
        return false
    }

    // If there is exactly one pipeline, validate it
    if (pipelines.size() == 1) {
        def pipelineMatch = pipelines[0]
        def pipelineContent = pipelineMatch[0] // Capture the entire pipeline block

        // Return false if invalid assignments are found
        if (!validateAssignments(pipelineContent)) {
            return false
        }

        // Return true if the pipeline is valid
        return true
    }

    return false // No pipelines found
}

// Example content with multiple pipelines and opening braces on new lines
def fileContent = """
// This is a single line comment
pipeline1 
{
    var1 = true // Valid
    var2 = false // Valid
    var3 = anotherVarName // Invalid
}

pipeline2 {
    def myMethod() { // Invalid
        // Some logic here
    }
    var4 = "someString" // Valid
}

pipeline3
{
    var5 = [1, 2, 3] // Valid
}
"""

println(validatePipelines(fileContent)) // This will print false if invalid
